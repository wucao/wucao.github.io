
 <!DOCTYPE HTML>
<html lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
  
    <title>密码学基础：编码方式、消息摘要算法、加密算法总结 | 叉叉哥的BLOG</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="wucao">
    

    
    <meta name="description" content="字节码转文本的编码方式在计算机中，无论是内存、磁盘、网络传输，涉及到的数据都是以二进制格式来存储或传输的。 每一个二进制位（bit）只能是 0 或 1。二进制位不会单独存在，而是以 8 个二进制位组成 1 个字节（byte）的方式存在，即 1 byte = 8 bit。 字节码无法直接转为可打印的文本字符，有时想通过文本方式配置、存储、传输一段二进制字节码，比如配置文件、HTML/XML、URL、">
<meta name="keywords" content="Java,MD5,SHA,AES,RSA,Base64">
<meta property="og:type" content="article">
<meta property="og:title" content="密码学基础：编码方式、消息摘要算法、加密算法总结">
<meta property="og:url" content="https://xxgblog.com/2021/11/30/cryptography/index.html">
<meta property="og:site_name" content="叉叉哥的BLOG">
<meta property="og:description" content="字节码转文本的编码方式在计算机中，无论是内存、磁盘、网络传输，涉及到的数据都是以二进制格式来存储或传输的。 每一个二进制位（bit）只能是 0 或 1。二进制位不会单独存在，而是以 8 个二进制位组成 1 个字节（byte）的方式存在，即 1 byte = 8 bit。 字节码无法直接转为可打印的文本字符，有时想通过文本方式配置、存储、传输一段二进制字节码，比如配置文件、HTML/XML、URL、">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://xxgblog.com/img/cryptography-md5-ship.jpg">
<meta property="og:image" content="https://xxgblog.com/img/cryptography-md5-plane.jpg">
<meta property="og:image" content="https://xxgblog.com/img/cryptography-jwt.png">
<meta property="og:image" content="https://xxgblog.com/img/java-aes-ecb.png">
<meta property="og:image" content="https://xxgblog.com/img/cryptography-certificate-sign.png">
<meta property="og:updated_time" content="2021-12-02T02:31:30.212Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="密码学基础：编码方式、消息摘要算法、加密算法总结">
<meta name="twitter:description" content="字节码转文本的编码方式在计算机中，无论是内存、磁盘、网络传输，涉及到的数据都是以二进制格式来存储或传输的。 每一个二进制位（bit）只能是 0 或 1。二进制位不会单独存在，而是以 8 个二进制位组成 1 个字节（byte）的方式存在，即 1 byte = 8 bit。 字节码无法直接转为可打印的文本字符，有时想通过文本方式配置、存储、传输一段二进制字节码，比如配置文件、HTML/XML、URL、">
<meta name="twitter:image" content="https://xxgblog.com/img/cryptography-md5-ship.jpg">

    
    <link rel="alternative" href="/atom.xml" title="叉叉哥的BLOG" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/xxg.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/xxg.jpg">
    
    <link rel="stylesheet" href="/css/style.css">
</head>
</html>
  <body>
    <header>
      
<div>
		
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="叉叉哥的BLOG">叉叉哥的BLOG</a></h1>
				<h2 class="blog-motto">Python毁一生，Java穷三代，两者皆不沾，必成高富帅！</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜单">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">主页</a></li>
					
						<li><a href="/archives">归档</a></li>
					
						<li><a href="https://github.com/wucao">GitHub</a></li>
					
						<li><a href="/about">关于</a></li>
					
					<li>
 					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" name="q" autocomplete="off" maxlength="20" placeholder="搜索">
						<input type="hidden" name="q" value="site:xxgblog.com">
					</form>
					
					</li>
				</ul>
			</ul></nav>
</div>

    </header>
    <div id="container">
      <div id="main" class="post" itemscope itemprop="blogPost">
  
	<article itemprop="articleBody"> 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2021/11/30/cryptography/" title="密码学基础：编码方式、消息摘要算法、加密算法总结" itemprop="url">密码学基础：编码方式、消息摘要算法、加密算法总结</a>
  </h1>
  <p class="article-time">
    <time datetime="2021-11-30T02:31:00.000Z" itemprop="datePublished"> 发表于 2021-11-30</time>

  </p>
</header>

	<div class="article-content">
		
		<div id="toc" class="toc-article">
			<strong class="toc-title">文章目录</strong>
		
			<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#字节码转文本的编码方式"><span class="toc-number">1.</span> <span class="toc-text">字节码转文本的编码方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#HEX-编码"><span class="toc-number">1.1.</span> <span class="toc-text">HEX 编码</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#RGB-颜色码"><span class="toc-number">1.1.1.</span> <span class="toc-text">RGB 颜色码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#URL-编码"><span class="toc-number">1.1.2.</span> <span class="toc-text">URL 编码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IPv6-地址"><span class="toc-number">1.1.3.</span> <span class="toc-text">IPv6 地址</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Base64-编码"><span class="toc-number">1.2.</span> <span class="toc-text">Base64 编码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#消息摘要算法"><span class="toc-number">2.</span> <span class="toc-text">消息摘要算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HMAC"><span class="toc-number">3.</span> <span class="toc-text">HMAC</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#JWT-中的-HMAC"><span class="toc-number">3.1.</span> <span class="toc-text">JWT 中的 HMAC</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#加密算法"><span class="toc-number">4.</span> <span class="toc-text">加密算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#对称加密算法"><span class="toc-number">4.1.</span> <span class="toc-text">对称加密算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#非对称加密算法"><span class="toc-number">4.2.</span> <span class="toc-text">非对称加密算法</span></a></li></ol></li></ol>
		
		</div>
		
		<h2 id="字节码转文本的编码方式"><a href="#字节码转文本的编码方式" class="headerlink" title="字节码转文本的编码方式"></a>字节码转文本的编码方式</h2><p>在计算机中，无论是内存、磁盘、网络传输，涉及到的数据都是以二进制格式来存储或传输的。</p>
<p>每一个二进制位（bit）只能是 0 或 1。二进制位不会单独存在，而是以 8 个二进制位组成 1 个字节（byte）的方式存在，即 1 byte = 8 bit。</p>
<p>字节码无法直接转为可打印的文本字符，有时想通过文本方式配置、存储、传输一段二进制字节码，比如配置文件、HTML/XML、URL、e-mail 正文、HTTP Header 等仅支持文本的场景下，就需要将二进制字节码转为文本字符串。</p>
<p>二进制字节码转文本字符有很多种方式，最简单的方式是直接用 0 和 1 来表示。但是这样的话，8 个 0/1 字符才能表示 1 个字节，长度太长很不方便。</p>
<p>下面介绍两种更加紧凑的方式：HEX 编码和 Base64 编码。</p>
<h3 id="HEX-编码"><a href="#HEX-编码" class="headerlink" title="HEX 编码"></a>HEX 编码</h3><p>HEX 是 16 进制的编码方式，所以又称为 Base16。</p>
<p>如果把一个字节中的二进制数值转为十六进制，使用 0-9 和 a-e（忽略大小写）这 16 个字符，那每个字符就可以表示 4 个二进制位（因为 2 的 4 次方等于 16），那么仅需要两个可打印字符就可以表示一个字节。</p>
<p>Java 中使用 HEX 编码（依赖 <a href="https://commons.apache.org/proper/commons-codec/" target="_blank" rel="noopener">Apache Commons Codec</a>）：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">"相对论"</span>;</span><br><span class="line"><span class="keyword">byte</span>[] bytes = str.getBytes(<span class="string">"UTF-8"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Hex 编码</span></span><br><span class="line">String encodeString = Hex.encodeHexString(bytes);</span><br><span class="line">System.out.println(encodeString); <span class="comment">// 输出：e79bb8e5afb9e8aeba</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Hex 解码</span></span><br><span class="line"><span class="keyword">byte</span>[] decodeBytes = Hex.decodeHex(encodeString);</span><br><span class="line">System.out.println(<span class="keyword">new</span> String(decodeBytes, <span class="string">"UTF-8"</span>)); <span class="comment">// 输出：相对论</span></span><br></pre></td></tr></table></figure></p>
<p>HEX 编码使用场景非常多。下面介绍几种常见的使用场景：</p>
<h4 id="RGB-颜色码"><a href="#RGB-颜色码" class="headerlink" title="RGB 颜色码"></a>RGB 颜色码</h4><p>RGB 颜色通常用 HEX 方式表示。如橘红色可以用 #FF4500 来表示：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.orangered</span> &#123; <span class="attribute">color</span>: <span class="number">#FF4500</span>; &#125;</span><br></pre></td></tr></table></figure></p>
<p>RGB 指红(red)绿(green)蓝(blue)三原色，这三种颜色按不同比例叠加后可以得到各式各样的颜色。三种颜色每种强度取值范围是 0~255，各需要 1 个字节来表示，共 3 个字节。</p>
<p>用 HEX 编码的表示某种 RGB 颜色，是一个长度为 6 位的字符串（通常还会加上 # 作为前缀，此时长度是 7 位）。例如 #FF4500 表示红绿蓝三原色的强度分别为 255、69、0。</p>
<h4 id="URL-编码"><a href="#URL-编码" class="headerlink" title="URL 编码"></a>URL 编码</h4><p>由于 URL 中仅允许出现字母、数字和一些特殊符号，当 URL 中有汉字，需要经过 URL 编码才可以。</p>
<p>例如百度百科”相对论”的页面 URL 是： <a href="https://baike.baidu.com/item/%E7%9B%B8%E5%AF%B9%E8%AE%BA/48750" target="_blank" rel="noopener">https://baike.baidu.com/item/%E7%9B%B8%E5%AF%B9%E8%AE%BA/48750</a></p>
<p>其中 %E7%9B%B8%E5%AF%B9%E8%AE%BA 实际上是将 ‘相对论’ 三个字用 UTF-8 编码后得到 9 个字节，再分别对这 9 个字节使用 HEX 编码并加上 ‘%’ 前缀得到的结果。</p>
<h4 id="IPv6-地址"><a href="#IPv6-地址" class="headerlink" title="IPv6 地址"></a>IPv6 地址</h4><p>由于 IPv4 的地址即将面临不够用的问题，取而代之的将会是 IPv6。IPv6 使用了 128 个二进制位的地址，通常会使用 HEX 编码方式来表示，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2001:0db8:0000:0000:0000:ff00:0042:8329</span><br></pre></td></tr></table></figure></p>
<h3 id="Base64-编码"><a href="#Base64-编码" class="headerlink" title="Base64 编码"></a>Base64 编码</h3><p>如果觉得 HEX 编码不够紧凑，那么还有更加紧凑的编码方式：Base64 编码。</p>
<p>Base64 编码共使用了 64 个字符来表示二进制位：26 个大写的 A-Z、26 个小写的 a-z、10 个数字 0-9、2 个特殊符号 + 和 /。这意味着每个字符可以表示 6 个二进制位，因为 64 等于 2 的 6 次方。</p>
<p>由于每个字节是 8 个二进制位，而 Base64 编码每个字符表示 6 个二进制位，那么可以每凑够 3 个字节（即 24 个二进制位），可将其编码为 4 个字符。如果被 base64 编码的原数据字节数不是 3 的倍数，那么会在末尾补上 1 或 2 个值为 0 的字节，凑到 3 的倍数后再进行 Base64 编码，编码后会在末尾添加 1 或 2 个 = 符号，表示补了多少个字节，这个在解码时会用到。</p>
<p>Java 中使用 Base64 编码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">"相对论"</span>;</span><br><span class="line"><span class="keyword">byte</span>[] bytes = str.getBytes(<span class="string">"UTF-8"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Base64 编码</span></span><br><span class="line">String encodeString = Base64.getEncoder().encodeToString(bytes);</span><br><span class="line">System.out.println(encodeString); <span class="comment">// 输出：55u45a+56K66</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Base64 解码</span></span><br><span class="line"><span class="keyword">byte</span>[] decodeBytes = Base64.getDecoder().decode(encodeString);</span><br><span class="line">System.out.println(<span class="keyword">new</span> String(decodeBytes, <span class="string">"UTF-8"</span>)); <span class="comment">// 输出：相对论</span></span><br></pre></td></tr></table></figure></p>
<p>Base64 编码的使用场景也有很多。例如，由于图片文件不是文本文件，没办法直接写入到 HTML 中，而将图片经过 Base64 编码后的结果是一串文本，可以直接放到 HTML 中：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"data:image/jpg;base64,/9j/4QMZR..."</span> /&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>需要注意的是，<strong>Base64 不是加密算法</strong>，有的开发人员把 Base64 当做加密算法来用，这是极其不安全的，因为 Base64 任何人都可以解码，不需要任何密钥。</p>
<h2 id="消息摘要算法"><a href="#消息摘要算法" class="headerlink" title="消息摘要算法"></a>消息摘要算法</h2><p>消息摘要算法（Message-Digest Algorithm），又称为密码散列函数（cryptographic hash function (CHF)），可以将任意长度的字节码数据通过哈希算法计算出一个固定大小的结果。常用的消息摘要算法有 MD5、SHA-1、SHA-2 系列（包括 SHA-256、SHA-512 等）。</p>
<p>以 MD5 为例，对任意一个数据进行 MD5 运算，结果是一个 128 个二进制位（16 个字节）的哈希值。而我们日常看到的 32 位 MD5 字符串，实际上是对 128 个二进制位的哈希值进行 HEX 编码后得到的结果。</p>
<p>例如，当使用 MD5 对 “相对论” 这个字符串进行运算，得到一个 32 位字符的 MD5 值，实际上是经过以下 3 个步骤（以下代码依赖 <a href="https://commons.apache.org/proper/commons-codec/" target="_blank" rel="noopener">Apache Commons Codec</a>）：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">"相对论"</span>;</span><br><span class="line"><span class="comment">// 1. 将字符串通过 UTF-8 编码转为字节数组</span></span><br><span class="line"><span class="keyword">byte</span>[] bytes = str.getBytes(<span class="string">"UTF-8"</span>);</span><br><span class="line"><span class="comment">// 2. 对原始数组进行 MD5，得到一个 128 个二进制位（16 个字节）的哈希值</span></span><br><span class="line"><span class="keyword">byte</span>[] md5Bytes = DigestUtils.md5(bytes);</span><br><span class="line"><span class="comment">// 3. 将 128 位的哈希值 HEX 编码，得到一个长度为 32 的字符串</span></span><br><span class="line">String md5Hex = Hex.encodeHexString(md5Bytes);</span><br><span class="line">System.out.println(md5Hex); <span class="comment">// 输出：fa913fb181bc1a69513e3d05a367da49</span></span><br></pre></td></tr></table></figure></p>
<p>上面的代码仅仅是为了更清晰的看到计算一个字符串 MD5 值的整个过程。实际开发中可以使用更加便捷的 API，将上面的 3 个步骤合为 1 步：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">"相对论"</span>;</span><br><span class="line"><span class="comment">// 使用默认的 UTF-8 编码将字符串转为字节数组计算 MD5 后再进行 HEX 编码</span></span><br><span class="line">String md5Hex = DigestUtils.md5Hex(str);</span><br><span class="line">System.out.println(md5Hex); <span class="comment">// 输出：fa913fb181bc1a69513e3d05a367da49</span></span><br></pre></td></tr></table></figure></p>
<p>除此之外，<a href="https://commons.apache.org/proper/commons-codec/" target="_blank" rel="noopener">Apache Commons Codec</a> 中的 <code>DigestUtils</code> 还提供了 SHA-1、SHA-256、SHA-384、SHA-512 等消息摘要算法。</p>
<p>消息摘要算法有以下特点：</p>
<ul>
<li>相同的消息通过消息摘要算法计算得到的结果总是相同的。</li>
<li>不同的消息通过消息摘要算法计算得到的结果要尽可能保证是不同的。如果两个不同的数据消息摘要后的结果相同，也就是发生了哈希碰撞，哈希碰撞出现的概率越大，那么这个消息摘要算法就越不安全。</li>
<li>不可逆，无法通过哈希结果反向推算出原始数据。所以，我们一般认为<strong>消息摘要算法并不算是加密算法</strong>，因为它无法解密。另外，这里的不可逆是指运算不可逆，但是攻击者通常会使用穷举法或彩虹表来找到哈希值对应的原始数据。</li>
</ul>
<p>下面列举一些典型的消息摘要算法的使用场景：</p>
<ul>
<li>对用户的登录密码使用消息摘要算法得到哈希值后再存储到数据库，即使数据库被黑客攻击，拿到所有的数据，也很难获得密码的原始值。这相对明文存储密码来说更加安全。当然，直接使用哈希值存储也是不安全的，特别是对于一些弱密码，黑客可以通过彩虹表轻松的查到对应的原始值。所以通常不会直接存储哈希值，而是经过一些处理，例如加盐、HMAC 等方式。</li>
<li>对比两个文件是否一致，只需要对比两个文件的消息摘要是否一致即可，无需按字节一个个去对比。例如百度网盘曾经就是用文件的 MD5 来判断新上传的文件是否已存在，如果已经存在则不需要重复上传和存储，达到节省空间的目的。</li>
<li>用于数字签名（Digital Signature），这个在本文后续会介绍。</li>
</ul>
<p>在安全性要求比较高的场景下，MD5、SHA-1 目前都已经不建议使用了，现在用的比较多的是 SHA-2 系列算法。</p>
<p>例如，MD5 相对来说很容易被碰撞攻击。下面两个完全不同的图片文件，分别计算它们的 MD5 值，会发现结果都是 253dd04e87492e4fc3471de5e776bc3d ：</p>
<p><img src="/img/cryptography-md5-ship.jpg" alt="两个 MD5 相同的图片-1"></p>
<p><img src="/img/cryptography-md5-plane.jpg" alt="两个 MD5 相同的图片-2"></p>
<p>大家有兴趣可以试试分别将两个图片传到百度网盘，可以发现有意思的事情：预览两个图片时可以发现变成同一个图片了。</p>
<h2 id="HMAC"><a href="#HMAC" class="headerlink" title="HMAC"></a>HMAC</h2><p>HMAC 全称是散列消息认证码（Hash-Based Message Authentication Code），它在消息摘要算法的基础上，加上了一个密钥（secret key）。</p>
<p>例如 HMAC-SHA256 就是在 SHA-256 算法基础上加了一个密钥。以下为代码示例（依赖 <a href="https://commons.apache.org/proper/commons-codec/" target="_blank" rel="noopener">Apache Commons Codec</a>）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">"相对论"</span>;</span><br><span class="line">String key = <span class="string">"12345678"</span>; <span class="comment">// 密钥</span></span><br><span class="line">HmacUtils hmacUtils = <span class="keyword">new</span> HmacUtils(HmacAlgorithms.HMAC_SHA_256, key.getBytes(<span class="string">"UTF-8"</span>));</span><br><span class="line">String result = hmacUtils.hmacHex(str.getBytes(<span class="string">"UTF-8"</span>));</span><br><span class="line">System.out.println(result); <span class="comment">// 输出：3bd7bbf58159a6d0bff846016b346a617a588fc1e9c43ebbdf38be53d3fc455a</span></span><br></pre></td></tr></table></figure>
<p>相对于直接使用消息摘要算法，使用 HMAC 优势在于，它可以对消息进行真实性（authenticity）和完整性（integrity）验证。</p>
<p>只要密钥没有泄露，那么只有持有密钥才可以计算和验证原始数据哈希值。攻击者在没有密钥的前提下，无法发送伪造的消息，也无法篡改消息。</p>
<p>HMAC 可用于接口认证。例如一个暴露在网络环境中的 HTTP 接口，如果想要对调用方进行认证，可以将密钥发放给调用方，要求调用方调用接口时，给所有请求参数使用密钥通过 HMAC 计算一个签名，被调用方验证签名，就可以保证请求参数的真实性和完整性。</p>
<p>另外，HMAC 由于在计算哈希值时添加了密钥，相对于直接使用消息摘要算法，更加不容易被穷举法、彩虹表破解，用户密码经过 HMAC 后保存更加安全。</p>
<h3 id="JWT-中的-HMAC"><a href="#JWT-中的-HMAC" class="headerlink" title="JWT 中的 HMAC"></a>JWT 中的 HMAC</h3><p>HMAC 的一个典型的应用场景就是 JWT。JWT 全称是 JSON Web Token。</p>
<p>传统的认证方式一般会将认证用户信息保存在服务端，而 JWT 直接将认证用户信息发放给客户端保存。既然 JWT 保存在客户端，那么任何人都可以伪造或篡改。如何解决这个问题，其中一种方式就是服务端会对 JWT 的 token 使用 HMAC 进行签名，并将签名也放在 token 末尾。下次客户端带上 JWT 请求时，服务端再验证签名是否正确。只要密钥不泄露，就可以保证 token 的真实性和完整性。</p>
<p>JWT token 分为三个部分：</p>
<ul>
<li>Header：头部，指定签名算法</li>
<li>Payload：包含 token 主要传输的信息，这一部分可以包含用户信息，例如用户名等</li>
<li>Signature：签名，计算方式如下（secret 即密钥）：  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HMACSHA256(</span><br><span class="line">  base64UrlEncode(header) + &quot;.&quot; +</span><br><span class="line">  base64UrlEncode(payload),</span><br><span class="line">  secret)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>最终对这三个部分 Base64 编码后组合为 JWT 的 token：<br><img src="/img/cryptography-jwt.png" alt="JWT token 的三个部分"></p>
<h2 id="加密算法"><a href="#加密算法" class="headerlink" title="加密算法"></a>加密算法</h2><p>加密算法分为对称加密算法和非对称加密算法：</p>
<ul>
<li>对称加密算法（symmetric-key cryptography）：加密和解密时使用相同的密钥。最常用的是 AES 算法。</li>
<li>非对称加密算法（asymmetric-key cryptography）：加密和解密使用不同的密钥，例如公钥加密的内容只能用私钥解密，所以又称为公钥加密算法（public-key cryptography）。使用最广泛的是 RSA 算法。</li>
</ul>
<h3 id="对称加密算法"><a href="#对称加密算法" class="headerlink" title="对称加密算法"></a>对称加密算法</h3><p>常见的对称加密算法有 DES、3DES、AES，其中 DES 和 3DES 标准由于安全性问题，已经逐渐被 AES 取代。</p>
<p>AES 有多种工作模式（mode of operation）和填充方式（padding）：</p>
<ul>
<li>工作模式：如 ECB、CBC、OFB、CFB、CTR、XTS、OCB、GCM，不同的模式参数和加密流程不同。</li>
<li>填充方式：由于 AES 是一种区块加密（block cipher）算法，加密时会将原始数据按大小拆分成一个个 128 比特（即 16 字节）区块进行加密，如果需要加密的原始数据不是 16 字节的整数倍时，就需要对原始数据进行填充，使其达到 16 字节的整数倍。常用的填充方式有 PKCS5Padding、ISO10126Padding 等，另外如果能保证待加密的原始数据大小为 16 字节的整数倍，也可以选择不填充，即 NoPadding。</li>
</ul>
<p>在实际工作中，需要跨团队跨语言对数据加密解密，经常出现使用一个语言加密后，另一个语言无法解密的情况。这一般都是两边选择的工作模式和填充方式不一致导致的。</p>
<p>下面的代码以 ECB 模式结合 PKCS5Padding 填充方式为例，对数据进行加密和解密：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] encryptECB(<span class="keyword">byte</span>[] data, <span class="keyword">byte</span>[] key) <span class="keyword">throws</span> NoSuchPaddingException, NoSuchAlgorithmException, InvalidKeyException, BadPaddingException, IllegalBlockSizeException &#123;</span><br><span class="line">    Cipher cipher = Cipher.getInstance(<span class="string">"AES/ECB/PKCS5Padding"</span>);</span><br><span class="line">    cipher.init(Cipher.ENCRYPT_MODE, <span class="keyword">new</span> SecretKeySpec(key, <span class="string">"AES"</span>));</span><br><span class="line">    <span class="keyword">byte</span>[] result = cipher.doFinal(data);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] decryptECB(<span class="keyword">byte</span>[] data, <span class="keyword">byte</span>[] key) <span class="keyword">throws</span> NoSuchPaddingException, NoSuchAlgorithmException, InvalidKeyException, BadPaddingException, IllegalBlockSizeException &#123;</span><br><span class="line">    Cipher cipher = Cipher.getInstance(<span class="string">"AES/ECB/PKCS5Padding"</span>);</span><br><span class="line">    cipher.init(Cipher.DECRYPT_MODE, <span class="keyword">new</span> SecretKeySpec(key, <span class="string">"AES"</span>));</span><br><span class="line">    <span class="keyword">byte</span>[] result = cipher.doFinal(data);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IllegalBlockSizeException, InvalidKeyException, BadPaddingException, NoSuchAlgorithmException, NoSuchPaddingException </span>&#123;</span><br><span class="line">    String data = <span class="string">"Hello World"</span>; <span class="comment">// 待加密的明文</span></span><br><span class="line">    String key = <span class="string">"12345678abcdefgh"</span>; <span class="comment">// key 长度只能是 16、25 或 32 字节</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">byte</span>[] ciphertext = encryptECB(data.getBytes(), key.getBytes());</span><br><span class="line">    System.out.println(<span class="string">"ECB 模式加密结果（Base64）："</span> + Base64.getEncoder().encodeToString(ciphertext));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">byte</span>[] plaintext = decryptECB(ciphertext, key.getBytes());</span><br><span class="line">    System.out.println(<span class="string">"解密结果："</span> + <span class="keyword">new</span> String(plaintext));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ECB 模式加密结果（Base64）：bB0gie8pCE2RBQoIAAIxeA==</span><br><span class="line">解密结果：Hello World</span><br></pre></td></tr></table></figure></p>
<p>上面的 ECB 模式虽然简单易用，但是安全性不高。由于该模式对每个 block 进行独立加密，会导致同样的明文块被加密成相同的密文块。下图就是一个很好的例子：<br><img src="/img/java-aes-ecb.png" alt="ECB 模式缺点"></p>
<p>在 CBC 模式中，引入了初始向量（IV，Initialization Vector）的概念，用于解决 ECB 模式的问题。</p>
<p>下面是 CBC 模式结合 PKCS5Padding 填充方式的代码示例，加密解密时相比 ECB 模式多了一个初始向量 iv 参数：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] encryptCBC(<span class="keyword">byte</span>[] data, <span class="keyword">byte</span>[] key, <span class="keyword">byte</span>[] iv) <span class="keyword">throws</span> NoSuchPaddingException, NoSuchAlgorithmException, InvalidKeyException, BadPaddingException, IllegalBlockSizeException, InvalidAlgorithmParameterException &#123;</span><br><span class="line">    Cipher cipher = Cipher.getInstance(<span class="string">"AES/CBC/PKCS5Padding"</span>);</span><br><span class="line">    cipher.init(Cipher.ENCRYPT_MODE, <span class="keyword">new</span> SecretKeySpec(key, <span class="string">"AES"</span>), <span class="keyword">new</span> IvParameterSpec(iv));</span><br><span class="line">    <span class="keyword">byte</span>[] result = cipher.doFinal(data);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] decryptCBC(<span class="keyword">byte</span>[] data, <span class="keyword">byte</span>[] key, <span class="keyword">byte</span>[] iv) <span class="keyword">throws</span> NoSuchPaddingException, NoSuchAlgorithmException, InvalidKeyException, BadPaddingException, IllegalBlockSizeException, InvalidAlgorithmParameterException &#123;</span><br><span class="line">    Cipher cipher = Cipher.getInstance(<span class="string">"AES/CBC/PKCS5Padding"</span>);</span><br><span class="line">    cipher.init(Cipher.DECRYPT_MODE, <span class="keyword">new</span> SecretKeySpec(key, <span class="string">"AES"</span>), <span class="keyword">new</span> IvParameterSpec(iv));</span><br><span class="line">    <span class="keyword">byte</span>[] result = cipher.doFinal(data);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IllegalBlockSizeException, InvalidKeyException, BadPaddingException, NoSuchAlgorithmException, NoSuchPaddingException, InvalidAlgorithmParameterException </span>&#123;</span><br><span class="line">    String data = <span class="string">"Hello World"</span>; <span class="comment">// 待加密的原文</span></span><br><span class="line">    String key = <span class="string">"12345678abcdefgh"</span>; <span class="comment">// key 长度只能是 16、25 或 32 字节</span></span><br><span class="line">    String iv = <span class="string">"iviviviviviviviv"</span>; <span class="comment">// CBC 模式需要用到初始向量参数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">byte</span>[] ciphertext = encryptCBC(data.getBytes(), key.getBytes(), iv.getBytes());</span><br><span class="line">    System.out.println(<span class="string">"CBC 模式加密结果（Base64）："</span> + Base64.getEncoder().encodeToString(ciphertext));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">byte</span>[] plaintext = decryptCBC(ciphertext, key.getBytes(), iv.getBytes());</span><br><span class="line">    System.out.println(<span class="string">"解密结果："</span> + <span class="keyword">new</span> String(plaintext));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CBC 模式加密结果（Base64）：K7bSB51+KxfqaMjJOsPAQg==</span><br><span class="line">解密结果：Hello World</span><br></pre></td></tr></table></figure></p>
<p>AES 使用非常广泛，可以说只要上网，无论是使用手机 APP 还是 Web 应用，几乎都离不开 AES 加密算法。目前大部分网站，包括手机 APP 后端接口，都已经使用 HTTPS 协议，而 HTTPS 在数据传输阶段大多都是使用 AES 对称加密算法。</p>
<p>但是，以 AES 为代表的的对称加密算法面临一个问题，就是如何安全的传输密钥。网络中发生数据交换的双方，需要用同一个密钥进行加密和解密，密钥一旦暴露，传输的内容就不再安全。密钥本身如果需要传输，如何保证安全？对于这个问题，就需要用到非对称加密算法。</p>
<h3 id="非对称加密算法"><a href="#非对称加密算法" class="headerlink" title="非对称加密算法"></a>非对称加密算法</h3><p>1977 年，Rivest、Shamir、Adleman 设计了 RSA 非对称加密算法，并以此获得了 2002 年的图灵奖（计算机领域的国际最高奖项，被誉为”计算机界的诺贝尔奖”）。至今，RSA 算法一直是最广为使用的非对称加密算法。</p>
<p>RSA 有两个密钥：公钥（public key）和私钥（private key）。</p>
<p>公钥可以完全公开，任何人都可以获取到。私钥是私有的，要保证不能被泄露出去。</p>
<p>公钥加密的内容，只有私钥可以解密。私钥加密的内容，也只有公钥可以解密。</p>
<p>基于以上规则，RSA 有两种不同的用法：</p>
<ul>
<li>公钥加密，私钥解密：服务端把公钥公开出去，客户端拿到公钥，把想要传输给服务端的数据通过公钥加密后传输，那么这个数据只有服务端能够解密，因为只有服务端拥有私钥，其他任何中间人即使在传输过程中拿到数据，既不能解密，也无法篡改。</li>
<li><p>私钥签名，公钥验证签名：内容发布者将发布的内容用消息摘要算法（如 SHA-256）计算哈希值，再用私钥加密哈希值，得到一个签名，并将签名加在发布内容中一起发布，其他人得到这个内容后，可以用公开的公钥解密签名得到哈希值，再对比这个哈希值和内容生成的哈希值是否一致，来保证这份内容没有被篡改过。</p>
<p>  由于只是验证数据的真实性完整性，所以无需对整个内容进行加密，仅需对内容的哈希值加密即可验证，所以通常会结合消息摘要算法。例如 SHA256 with RSA 签名，就是先用 SHA-256 计算出哈希值，再用 RSA 私钥加密。</p>
</li>
</ul>
<p>上面说到的私钥加密、公钥解密只是理论上成立，实际上不会直接这样用，而是只用于签名。因为一段私钥加密的数据，解密的公钥是公开的，意味着谁都可以解密，这样加密就没有任何意义了。</p>
<p>接下来通过 Java 代码来体验一下 RSA 算法。</p>
<p>首先，需要生成一对公钥和私钥。下面通过 openssl 命令来生成一对公钥和私钥：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个 PKCS#8 格式 2048 位的私钥</span></span><br><span class="line">openssl genpkey -out private_key.pem -algorithm RSA -pkeyopt rsa_keygen_bits:2048</span><br><span class="line"><span class="comment"># 通过私钥生成公钥</span></span><br><span class="line">openssl pkey -<span class="keyword">in</span> private_key.pem -pubout -out public_key.pem</span><br></pre></td></tr></table></figure></p>
<p>生成的公钥和私钥是 Base64 编码的文本文件，可以直接用文本编辑器打开。拷贝到下面的代码中，可以验证公钥加密、私钥解密，以及私钥签名、公钥验证签名：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    String publicKeyBase64 = <span class="string">"MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA0XYlulDsTzDWUb6X66Ia\n"</span> +</span><br><span class="line">            <span class="string">"giSn1dKriHvLHYth9hCcaGomdeIQahGnxzE1o76slEyS2HZ164QHqx8Za+LuT6IV\n"</span> +</span><br><span class="line">            <span class="string">"yLhU/ZNLWAZABe/sdNEkhti6vSSOdJE43KS4UVADeSgtN+7uXDuVgm35EPWZjkfV\n"</span> +</span><br><span class="line">            <span class="string">"5hiRX4nT5ALr1niyi1Ax4BWWyG4qX00n1HzY8MvoyiLdNob71qB+amjUNy9bDhcz\n"</span> +</span><br><span class="line">            <span class="string">"CDWtgA/ywOYU5Ec6vMgYfbAXPKGWwo318rS3UH8QtsO8iGcQbZ76q05LNEL8G3fo\n"</span> +</span><br><span class="line">            <span class="string">"0Kssj4fjrVGwSsyGztRRMLfGkW/hOPCDj82+D6dGQlGB3gyB7P1xVbkD67FujQA/\n"</span> +</span><br><span class="line">            <span class="string">"jwIDAQAB"</span>;</span><br><span class="line">    String privateKeyBase64 = <span class="string">"MIIEvQIBADANBgkqhkiG9w0BAQEFAASCBKcwggSjAgEAAoIBAQDRdiW6UOxPMNZR\n"</span> +</span><br><span class="line">            <span class="string">"vpfrohqCJKfV0quIe8sdi2H2EJxoaiZ14hBqEafHMTWjvqyUTJLYdnXrhAerHxlr\n"</span> +</span><br><span class="line">            <span class="string">"4u5PohXIuFT9k0tYBkAF7+x00SSG2Lq9JI50kTjcpLhRUAN5KC037u5cO5WCbfkQ\n"</span> +</span><br><span class="line">            <span class="string">"9ZmOR9XmGJFfidPkAuvWeLKLUDHgFZbIbipfTSfUfNjwy+jKIt02hvvWoH5qaNQ3\n"</span> +</span><br><span class="line">            <span class="string">"L1sOFzMINa2AD/LA5hTkRzq8yBh9sBc8oZbCjfXytLdQfxC2w7yIZxBtnvqrTks0\n"</span> +</span><br><span class="line">            <span class="string">"Qvwbd+jQqyyPh+OtUbBKzIbO1FEwt8aRb+E48IOPzb4Pp0ZCUYHeDIHs/XFVuQPr\n"</span> +</span><br><span class="line">            <span class="string">"sW6NAD+PAgMBAAECggEABT96joJ8iTdmB0JJOCQlmeElO1w94/uGCUV2vN2JrawL\n"</span> +</span><br><span class="line">            <span class="string">"LqTtWFr84ya+e03JsSWCAF5ncfEq6AStdGCJLAGZnh/QMVJBbwEpFXz/ZaXfzmkb\n"</span> +</span><br><span class="line">            <span class="string">"tKV31D/XNuABpjfk/mIdT+tymWj8w/nRZbVhlYkDOPKgoc4oOuw/0G3Ru1/VABI+\n"</span> +</span><br><span class="line">            <span class="string">"yulNx93A/JNFGk3Bkm4E7jRWyl0BkAqAX2BZkFbXG/u3Jc0eYXrG74JfMH+MEihG\n"</span> +</span><br><span class="line">            <span class="string">"GDMSpBKNyX5zWkUT6XxpG82t2erHPWYEoNSoFzAUu+7rZ4ECEXxazAQclEHTkR3r\n"</span> +</span><br><span class="line">            <span class="string">"duUZ/XF0GL1WB0GC7+qvV/Z0gxjXuwG9oToFO/0MQQKBgQDu4DuTPWcYwSWY0R1f\n"</span> +</span><br><span class="line">            <span class="string">"qZUOuYRwD+5OQnJMIlKAD32QmvYT/jnvigjss5Qf1IUwf1UMynj2FnVF4D7L+kvq\n"</span> +</span><br><span class="line">            <span class="string">"O7LzYvHAeDQwZGGt2xWBlqjfhumlfBqfklkkqUiH2A5DvfvtbX/kkiY3n9C+oYZp\n"</span> +</span><br><span class="line">            <span class="string">"2ejiOtSC+NqQeB74TluxroEkvwKBgQDgehynybpFl4KkmDhgj++BH5RR+xzXIChb\n"</span> +</span><br><span class="line">            <span class="string">"gtIbbspdE1EyXy7Z9iNAJ8PVjHkSwh8iEfAO4EuJFnonF8UNIsWLr3gsKbQytRxR\n"</span> +</span><br><span class="line">            <span class="string">"cewqaBhTL54Vgl5dmODNrYjkZva5HHDsCLioYGgljdrj5e/gPSAWBrgT6kI+HypQ\n"</span> +</span><br><span class="line">            <span class="string">"/5xyp+KJMQKBgQCMxut1P8eliBa/M+YqvYdR8TVC0bCwwGoZwlR6kiZ+9UQ2zimY\n"</span> +</span><br><span class="line">            <span class="string">"qPHPhZmzFI0V4sTdz+lvphahAqIfljftKBezZklxE6Y2KsKCMk4/W+nUKe9Cjpwm\n"</span> +</span><br><span class="line">            <span class="string">"FJqih31uSX9Gnw18hH7N1u/c8juUTR8o/LpJsUASm9Q7Nf+SeKODWINVgwKBgDEx\n"</span> +</span><br><span class="line">            <span class="string">"UXpLsPBzRYQAf8pZgKkRXJWirC1QtMdpIdY1L0+6Xf7l8QR+9janADmaMSY1OFFl\n"</span> +</span><br><span class="line">            <span class="string">"EPCRorwGGvraMKqyRgxYhcNX2E+MdQo8Jv8cFMiWFNSt3zQvvoQUVX2IOuVSIET5\n"</span> +</span><br><span class="line">            <span class="string">"nE354pjoP2HWD/1aJ9/r1Qc4PRAUEFfzzDssI27hAoGAOsYKtvW6iRn/WVduIRcy\n"</span> +</span><br><span class="line">            <span class="string">"UtBRHHX0U16zGv+I7nOOBIYK5Uan6AjgzG2MfPOBj3cUhMMBDPfVg1cTbonw5Y8F\n"</span> +</span><br><span class="line">            <span class="string">"nSO4VLOtqKy0BRxCIUFqltJXUmj1zAJs84IweCBQ3un/OLVUMgE7qGtaIQy2PBsy\n"</span> +</span><br><span class="line">            <span class="string">"M8mwuUjo3Fu7l11E2Vgz/qY="</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Base64 解码</span></span><br><span class="line">    <span class="keyword">byte</span>[] publicKeyBytes = Base64.getDecoder().decode(publicKeyBase64.replace(<span class="string">"\n"</span>, <span class="string">""</span>));</span><br><span class="line">    <span class="keyword">byte</span>[] privateKeyBytes = Base64.getDecoder().decode(privateKeyBase64.replace(<span class="string">"\n"</span>, <span class="string">""</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成 PublicKey（公钥） 和 PrivateKey（私钥） 对象</span></span><br><span class="line">    PublicKey publicKey = KeyFactory.getInstance(<span class="string">"RSA"</span>).generatePublic(<span class="keyword">new</span> X509EncodedKeySpec(publicKeyBytes));</span><br><span class="line">    PrivateKey privateKey = KeyFactory.getInstance(<span class="string">"RSA"</span>).generatePrivate(<span class="keyword">new</span> PKCS8EncodedKeySpec(privateKeyBytes));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 待加密、签名的原文</span></span><br><span class="line">    String data = <span class="string">"Hello World"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 公钥加密，私钥解密</span></span><br><span class="line">    <span class="keyword">byte</span>[] ciphertext = encrypt(data.getBytes(), publicKey);</span><br><span class="line">    System.out.println(<span class="string">"RSA 公钥加密结果（Base64）："</span> + Base64.getEncoder().encodeToString(ciphertext));</span><br><span class="line">    <span class="keyword">byte</span>[] plaintext = decrypt(ciphertext, privateKey);</span><br><span class="line">    System.out.println(<span class="string">"RSA 私钥解密结果："</span> + <span class="keyword">new</span> String(plaintext));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私钥签名，公钥验证签名</span></span><br><span class="line">    <span class="keyword">byte</span>[] signature = sign(data.getBytes(), privateKey);</span><br><span class="line">    System.out.println(<span class="string">"RSA 私钥签名结果（Base64）："</span> + Base64.getEncoder().encodeToString(signature));</span><br><span class="line">    <span class="keyword">boolean</span> verifySuccess = verify(data.getBytes(), signature, publicKey);</span><br><span class="line">    System.out.println(<span class="string">"RSA 公钥验证签名结果："</span> + verifySuccess);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 公钥加密</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] encrypt(<span class="keyword">byte</span>[] data, PublicKey publicKey) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    Cipher cipher = Cipher.getInstance(<span class="string">"RSA"</span>);</span><br><span class="line">    cipher.init(Cipher.ENCRYPT_MODE, publicKey);</span><br><span class="line">    <span class="keyword">byte</span>[] result = cipher.doFinal(data);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 私钥解密</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] decrypt(<span class="keyword">byte</span>[] data, PrivateKey privateKey) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    Cipher cipher = Cipher.getInstance(<span class="string">"RSA"</span>);</span><br><span class="line">    cipher.init(Cipher.DECRYPT_MODE, privateKey);</span><br><span class="line">    <span class="keyword">byte</span>[] result = cipher.doFinal(data);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 私钥签名，使用 SHA256 with RSA 签名</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] sign(<span class="keyword">byte</span>[] data, PrivateKey privateKey) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    Signature signature = Signature.getInstance(<span class="string">"SHA256withRSA"</span>);</span><br><span class="line">    signature.initSign(privateKey);</span><br><span class="line">    signature.update(data);</span><br><span class="line">    <span class="keyword">byte</span>[] result = signature.sign();</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 公钥验证签名</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">verify</span><span class="params">(<span class="keyword">byte</span>[] data, <span class="keyword">byte</span>[] sign, PublicKey publicKey)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Signature signature = Signature.getInstance(<span class="string">"SHA256withRSA"</span>);</span><br><span class="line">    signature.initVerify(publicKey);</span><br><span class="line">    signature.update(data);</span><br><span class="line">    <span class="keyword">return</span> signature.verify(sign);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RSA 公钥加密结果（Base64）：zoY6KM/RdCjAs7upJ9SIwqfXsSn3hAPu/z/ZPHbKgWN6+X0PpyVJVYT8jacEkzB7S2sJe/wLkO2TqXB2gqvL1AuDRgepVlxV2f6Uwx4DxM2/5RE0fAdTiICV5JEEIw81oLix0GGQ7nLjOhJxN9LaTJ2cXtwgR8gUtLtJ0tdWrxSMuN8FHLA45Nv8Ea1EAUQCvfanYZ2L39l++3/zBdg2wYQwCE6XGFnWnayUsGKYjC7JIufnq5f9VDL/kguLKceLmeTHqq31ccRTOQyhuoZjHCsbfXPlW2AT9ejgAcXy7LkXhYCfma50DBM+KUCfC4YrKBg6wKRqdZee90ZPcUKTkw==</span><br><span class="line">RSA 私钥解密结果：Hello World</span><br><span class="line">RSA 私钥签名结果（Base64）：AbP5zSV/qvkF8fCseVkEaZMscvznQBUDtO3g0U/FIXVmzeR6WXFwPsMd3cC3oCHtnnqsL/aRQrpW6pHU6EzSJ5w6FgY6kD4kWREq9f8LOnyQm7CoS6CK0tUiAjIgG16rtmS+oPbG+mYaZkLzo1Cpkpz2MzuMMbWNivvXRMbj3wLiXyIMqUefawipvm+GPwrWRxesRot2sGtuZcxtMMZs3NHpJ0CXV/mQlYJWEzIiHUY4mqfqpMDL/djPf9td74ABpjk38O6r1Jt75TLnMvkwRdh7pHBQLZ0Tn/6Vx2cVD2D+sE9BuhinO66B6I0QOGVcl3a5C2whp+85zEovvdGlSg==</span><br><span class="line">RSA 公钥验证签名结果：true</span><br></pre></td></tr></table></figure></p>
<p>目前随处可见的 HTTPS 协议，是基于 SSL/TLS 协议的。在 SSL/TLS 协议中，建立加密的传输通道前，首先有一个握手过程。在握手过程中，客户端会生成一个随机值，并使用公钥加密后传给服务端。这个随机值用于生成对称加密算法的密钥，仅有服务端的私钥可以解密，任何第三方都无法解密，这就解决了前面所说到的对称加密算法密钥传输过程中的安全问题。而握手成功后的通信阶段，则使用对称加密算法进行通信。因为非对称加密算法更加复杂，相对于对称加密算法来说效率不高，不适合用来做大量数据的加密解密。</p>
<p>另外，SSL/TLS 中用到的数字证书（digital certificate），为了防止伪造，也会由 CA 机构进行数字签名。目前大多数 HTTPS 网站使用的数字证书都是使用 SHA256 with RSA 签名。</p>
<p>例如，在浏览器上打开 <a href="https://xxgblog.com/">https://xxgblog.com/</a> ，点击地址栏左侧的小锁按钮，查看网站使用的证书，其数字签名算法就是 SHA256 with RSA ：</p>
<p><img src="/img/cryptography-certificate-sign.png" alt="证书签名算法"></p>
  
	</div>
		<footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/Java/">Java</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/Java/">Java</a><a href="/tags/MD5/">MD5</a><a href="/tags/SHA/">SHA</a><a href="/tags/AES/">AES</a><a href="/tags/RSA/">RSA</a><a href="/tags/Base64/">Base64</a>
  </div>

</div>



	<div class="article-share" id="share">
	
	  <div data-url="https://xxgblog.com/2021/11/30/cryptography/" data-title="密码学基础：编码方式、消息摘要算法、加密算法总结 | 叉叉哥的BLOG" data-tsina class="share clearfix">
	  </div>
	
	</div>


</footer>

   	       
	</article>
	
<nav class="article-nav clearfix">
 
 <div class="prev">
 <a href="/2023/02/21/elastic-resilient/" title="软件架构中“弹性”的多种含义">
  <strong>上一篇：</strong><br>
  <span>
  软件架构中“弹性”的多种含义</span>
</a>
</div>


<div class="next">
<a href="/2021/10/19/decorator-pattern/" title="设计模式中的俄罗斯套娃：装饰者（Decorator）模式">
 <strong>下一篇：</strong><br> 
 <span>设计模式中的俄罗斯套娃：装饰者（Decorator）模式
</span>
</a>
</div>

</nav>

	




<div id="gitalk-container" style="padding: 0 4%;"></div>

</div>  
      <div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div>

  <div id="toc" class="toc-aside">
  <strong class="toc-title">文章目录</strong>
 
 <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#字节码转文本的编码方式"><span class="toc-number">1.</span> <span class="toc-text">字节码转文本的编码方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#HEX-编码"><span class="toc-number">1.1.</span> <span class="toc-text">HEX 编码</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#RGB-颜色码"><span class="toc-number">1.1.1.</span> <span class="toc-text">RGB 颜色码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#URL-编码"><span class="toc-number">1.1.2.</span> <span class="toc-text">URL 编码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IPv6-地址"><span class="toc-number">1.1.3.</span> <span class="toc-text">IPv6 地址</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Base64-编码"><span class="toc-number">1.2.</span> <span class="toc-text">Base64 编码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#消息摘要算法"><span class="toc-number">2.</span> <span class="toc-text">消息摘要算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HMAC"><span class="toc-number">3.</span> <span class="toc-text">HMAC</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#JWT-中的-HMAC"><span class="toc-number">3.1.</span> <span class="toc-text">JWT 中的 HMAC</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#加密算法"><span class="toc-number">4.</span> <span class="toc-text">加密算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#对称加密算法"><span class="toc-number">4.1.</span> <span class="toc-text">对称加密算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#非对称加密算法"><span class="toc-number">4.2.</span> <span class="toc-text">非对称加密算法</span></a></li></ol></li></ol>
 
  </div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隐藏侧边栏"></a></div>
<aside class="clearfix">

  <div class="github-card">
<p class="asidetitle">微信公众号</p>
<div>
<img src="/img/WechatPublic.jpg" style="width: 100%;">
</div>
</div>


  
<div class="categorieslist">
	<p class="asidetitle">分类</p>
		<ul>
		
		  
			<li><a href="/categories/Android/" title="Android">Android<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/Java/" title="Java">Java<sup>22</sup></a></li>
		  
		
		  
			<li><a href="/categories/Jetty/" title="Jetty">Jetty<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/Maven/" title="Maven">Maven<sup>6</sup></a></li>
		  
		
		  
			<li><a href="/categories/MyBatis/" title="MyBatis">MyBatis<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Nginx/" title="Nginx">Nginx<sup>5</sup></a></li>
		  
		
		  
			<li><a href="/categories/Node-js/" title="Node.js">Node.js<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Redis/" title="Redis">Redis<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Spring-Cloud/" title="Spring Cloud">Spring Cloud<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Spring-Framework/" title="Spring Framework">Spring Framework<sup>6</sup></a></li>
		  
		
		  
			<li><a href="/categories/Struts-2/" title="Struts 2">Struts 2<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/XMPP/" title="XMPP">XMPP<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/异步网络编程/" title="异步网络编程">异步网络编程<sup>13</sup></a></li>
		  
		
		  
			<li><a href="/categories/架构/" title="架构">架构<sup>1</sup></a></li>
		  
		
		</ul>
</div>


  
<div class="tagslist">
	<p class="asidetitle">标签</p>
		<ul class="clearfix">
		
			
				<li><a href="/tags/Java/" title="Java">Java<sup>51</sup></a></li>
			
		
			
				<li><a href="/tags/Netty/" title="Netty">Netty<sup>13</sup></a></li>
			
		
			
				<li><a href="/tags/MINA/" title="MINA">MINA<sup>12</sup></a></li>
			
		
			
				<li><a href="/tags/Twisted/" title="Twisted">Twisted<sup>12</sup></a></li>
			
		
			
				<li><a href="/tags/TCP/" title="TCP">TCP<sup>12</sup></a></li>
			
		
			
				<li><a href="/tags/Python/" title="Python">Python<sup>12</sup></a></li>
			
		
			
				<li><a href="/tags/Spring-Framework/" title="Spring Framework">Spring Framework<sup>8</sup></a></li>
			
		
			
				<li><a href="/tags/Maven/" title="Maven">Maven<sup>8</sup></a></li>
			
		
			
				<li><a href="/tags/线程/" title="线程">线程<sup>5</sup></a></li>
			
		
			
				<li><a href="/tags/Nginx/" title="Nginx">Nginx<sup>5</sup></a></li>
			
		
			
				<li><a href="/tags/protobuf/" title="protobuf">protobuf<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/Jetty/" title="Jetty">Jetty<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/JavaScript/" title="JavaScript">JavaScript<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/Redis/" title="Redis">Redis<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/Android/" title="Android">Android<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/AES/" title="AES">AES<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/WebSocket/" title="WebSocket">WebSocket<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/MySQL/" title="MySQL">MySQL<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/XMPP/" title="XMPP">XMPP<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/Tigase/" title="Tigase">Tigase<sup>2</sup></a></li>
			
		
		</ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">友情链接</p>
    <ul>
        
          <li>
            
            	<a href="http://lovecindywang.cnblogs.com/" target="_blank" title="朱晔的博客">朱晔的博客</a>
            
          </li>
        
          <li>
            
            	<a href="http://opstrip.com/" target="_blank" title="石尧的博客">石尧的博客</a>
            
          </li>
        
          <li>
            
            	<a href="https://blog.csdn.net/eson_15" target="_blank" title="倪升武的博客">倪升武的博客</a>
            
          </li>
        
          <li>
            
            	<a href="http://blog.csdn.net/noaman_wgs" target="_blank" title="王根深的博客">王根深的博客</a>
            
          </li>
        
          <li>
            
            	<a href="https://www.cnblogs.com/jy107600" target="_blank" title="蒋宇的博客">蒋宇的博客</a>
            
          </li>
        
    </ul>
</div>

  <div class="rsspart">
	<a href="/atom.xml" target="_blank" title="rss">RSS 订阅</a>
</div>

</aside>
</div>
    </div>
    <footer><div id="footer">
	
	
	<div class="social-font">
		
		
		
		
		
		
		
		
		
		
	</div>
			
		

		<p style="text-align: center; font-size: 0.7em;">、
			<a href="https://beian.miit.gov.cn" target="_blank" style="color: white;">皖ICP备15002890号-2</a>
		</p>

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a> © 2024
		
		<a href="/about" target="_blank" title="wucao">wucao</a>
		

		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize();
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
      
      $('#toc.toc-aside').css('display', 'none');
      
    }
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  c.click(function(){
    ta.css('display', 'block').addClass('fadeIn');
  });
  o.click(function(){
    ta.css('display', 'none');
  });
  $(window).scroll(function(){
    ta.css("top",Math.max(140,320-$(this).scrollTop()));
  });
});
</script>


<script type="text/javascript">
$(document).ready(function(){
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina'),
      description = $this.attr('description');
  var html = [
  '<div class="hoverqrcode clearfix"></div>',
  '<a class="overlay" id="qrcode"></a>',
  '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="微信"></a>',
  '<a href="http://widget.renren.com/dialog/share?resourceUrl=' + encodedUrl + '&srcUrl=' + encodedUrl + '&title=' + title +'" class="article-share-renren" target="_blank" title="人人"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="微博"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);

  $('.hoverqrcode').hide();

  var myWidth = 0;
  function updatehoverqrcode(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
    var qrsize = myWidth > 1024 ? 200:100;
    var options = {render: 'image', size: qrsize, fill: '#2ca6cb', text: url, radius: 0.5, quiet: 1};
    var p = $('.article-share-qrcode').position();
    $('.hoverqrcode').empty().css('width', qrsize).css('height', qrsize)
                          .css('left', p.left-qrsize/2+20).css('top', p.top-qrsize-10)
                          .qrcode(options);
  };
  $(window).resize(function(){
    $('.hoverqrcode').hide();
  });
  $('.article-share-qrcode').click(function(){
    updatehoverqrcode();
    $('.hoverqrcode').toggle();
  });
  $('.article-share-qrcode').hover(function(){}, function(){
      $('.hoverqrcode').hide();
  });
});
</script>








<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
<script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
<script type="text/javascript">
const gitalk = new Gitalk({
  clientID: 'ce21dd1e4d8a2819290e',
  clientSecret: 'f0786f8810407db32800529b6533331d672c6eff',
  repo: 'xxg-blog-message-board',
  owner: 'wucao',
  admin: ['wucao'],
  id: location.pathname.split('/')[4]
});
$(document).ready(function() {
  gitalk.render('gitalk-container');
});
</script>





<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
});
</script>



<!-- Analytics Begin -->



<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?e6d1f421bbc9962127a50488f9ed37d1";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
</script>



<div style="height: 0px; overflow: hidden">
<script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1254684152'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s23.cnzz.com/z_stat.php%3Fid%3D1254684152' type='text/javascript'%3E%3C/script%3E"));</script>
</div>


<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="返回顶部"><img src="/img/scrollup.png"></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
</html>
